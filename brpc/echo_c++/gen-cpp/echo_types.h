/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef echo_TYPES_H
#define echo_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>


namespace example {

class Echo2Request;

class ProxyRequest;

class Echo2Response;

typedef struct _Echo2Request__isset {
  _Echo2Request__isset() : data(false), need_by_proxy(false) {}
  bool data :1;
  bool need_by_proxy :1;
} _Echo2Request__isset;

class Echo2Request : public virtual ::apache::thrift::TBase {
 public:

  Echo2Request(const Echo2Request&);
  Echo2Request& operator=(const Echo2Request&);
  Echo2Request() : data(), need_by_proxy(0) {
  }

  virtual ~Echo2Request() throw();
  std::string data;
  int32_t need_by_proxy;

  _Echo2Request__isset __isset;

  void __set_data(const std::string& val);

  void __set_need_by_proxy(const int32_t val);

  bool operator == (const Echo2Request & rhs) const
  {
    if (__isset.data != rhs.__isset.data)
      return false;
    else if (__isset.data && !(data == rhs.data))
      return false;
    if (__isset.need_by_proxy != rhs.__isset.need_by_proxy)
      return false;
    else if (__isset.need_by_proxy && !(need_by_proxy == rhs.need_by_proxy))
      return false;
    return true;
  }
  bool operator != (const Echo2Request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Echo2Request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Echo2Request &a, Echo2Request &b);

std::ostream& operator<<(std::ostream& out, const Echo2Request& obj);

typedef struct _ProxyRequest__isset {
  _ProxyRequest__isset() : need_by_proxy(false) {}
  bool need_by_proxy :1;
} _ProxyRequest__isset;

class ProxyRequest : public virtual ::apache::thrift::TBase {
 public:

  ProxyRequest(const ProxyRequest&);
  ProxyRequest& operator=(const ProxyRequest&);
  ProxyRequest() : need_by_proxy(0) {
  }

  virtual ~ProxyRequest() throw();
  int32_t need_by_proxy;

  _ProxyRequest__isset __isset;

  void __set_need_by_proxy(const int32_t val);

  bool operator == (const ProxyRequest & rhs) const
  {
    if (__isset.need_by_proxy != rhs.__isset.need_by_proxy)
      return false;
    else if (__isset.need_by_proxy && !(need_by_proxy == rhs.need_by_proxy))
      return false;
    return true;
  }
  bool operator != (const ProxyRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProxyRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ProxyRequest &a, ProxyRequest &b);

std::ostream& operator<<(std::ostream& out, const ProxyRequest& obj);


class Echo2Response : public virtual ::apache::thrift::TBase {
 public:

  Echo2Response(const Echo2Response&);
  Echo2Response& operator=(const Echo2Response&);
  Echo2Response() : data() {
  }

  virtual ~Echo2Response() throw();
  std::string data;

  void __set_data(const std::string& val);

  bool operator == (const Echo2Response & rhs) const
  {
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const Echo2Response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Echo2Response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Echo2Response &a, Echo2Response &b);

std::ostream& operator<<(std::ostream& out, const Echo2Response& obj);

} // namespace

#endif
